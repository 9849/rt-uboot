RT-Uboot
一个开源的QCA/AR/MTK/RT多线程uboot mod

声明：这是一个uboot的mod版，不是一个全新的bootloader，该uboot_mod才刚刚起步，目前建议仅供交流学习使用

另外github中包含的是QCA/AR系列的rt-uboot，这部分每一个soc的代码我都真机测试过，MTK/RT的由于手里没有机器没做测试，就先不发了，等测试好之后补上

本文的目的呢，并不是想宣传这个uboot_mod，而是想交流一下其设计原理
根据楼主计划，第一篇大致章节如下：
前言
1.uboot本身的坑
2.rtos-kernel选型
3.rtos-集成及遇到的问题
4.由于位置无关技术引发的特殊处理
5.demo
尾言
随更随写，后续篇幅将逐渐介绍更多功能及其实现机理，比如引入中断的驱动程序、mips calltrace、pcie千兆网卡的驱动和引入posix机制等...

现在先更第一篇（相应的，github也是对应第一篇的程序，后续的章节会随着发布而添加新的branch）

前言
楼主是如何想起来要做这个的呢？
这还要从头说起，楼主的妈妈是一个物联网工程师，主要做基于OpenWRT的各类软件开发，楼主的爸爸是某研究所的，主要做基于龙芯的底层开发。
因此作为一个从小接受uboot、openwrt熏陶的女汉子，楼主的童年就是在各种编译中度过的。
事情发生在一周前，当时一家人吃晚饭的时候，突然就聊到了uboot，当然也就聊到了某个著名的、功能强大的多线程bootloader，爸妈就聊起了整个bootloder的技术实现，我爸突然说起，他曾经设计过一个实时linux_mod，自带Linux镜像烧录功能，也算是个多线程bootloader吧。
说实话，我用某个著名的、功能强大的多线程bootloader已经很久了，可是一直不清楚多线程bootloader的技术细节，于是我表示对此很感兴趣，希望我爸能教我设计一个多线程bootloader，于是这就顺理成章的成了我这周的第二课堂作业。

终于经过五天晚上和两整天的努力，我完成了多线程bootloader的设计，由于是uboot魔改版，姑且叫rt-uboot吧。

1.uboot本身的坑
Uboot是一个非常古老的bootloader，可用于引导多种处理器平台，而QCA/AR/MTK/RT平台使用的是其中的1.1.4版，也算是很老的一版了，在其本身之中，存在着一些会对操作系统运行产生致命影响的深坑：
（1）K0全局指针问题
Mips架构中，中断异常可以使用的寄存器是k0，k1，因此普通程序是不能使用的，因为它很有可能会在你眼皮子底下发生变化，但是在AR/QCA的uboot中，在没有进行RAM初始化之前，k0被当做全局数据指针使用，这会导致软件GG
但是，其实当RAM初始化之后，k0就已经没有必要使用了，那么不如我们将程序改一点，当RAM初始化后，使用全局变量维护全局数据。
（2）Timer使用问题
作为一个rtos，它的本质是在timer中断（或者其他中断）中对线程进行调度，因此timer很重要，但是uboot将timer用作delay函数的延时标志了，那么不如加个指示量，当rtos运行之后把函数指向rtos的delay函数好了。
（3）部分寄存器寻址问题
Mips在内核态默认寻址kseg0和kseg1，而uboot没有将实际地址映射到其中，直接导致tlb错误，这部分就直接改正吧。

2.rtos-kernel选型
在uboot中使用rtos，自己写其实也可以，楼主还是自己写过rtos的，但是，使用第三方rtos的好处是可以有大量的团队进行代码的维护，免去自己维护的尴尬，而且本身这套程序就打算开源，因此用开源的第三方rtos也是上上之选。
基本上可选的rtos如下：
1.freertos：最广泛的rtos，不过除了内核啥都没有。
2.Uc/os：同rtos，商业应用还要收费。
3.Rt-thread：非常棒的国产rtos，外围组件支持度极其丰富。
4.Alios-things：阿里出品，但是乱，组件乱的一团糟，不知道开发团队怎么凑出来的。
5.Liteos：华为出品，但是组件太少。
6.Ecos：巨强的一个rtos，但是是c++的，不喜欢。
7.SMT-OS：楼主自己写的rtos，主要为某些DSP设计，使用了大量的DSP优化技巧如软中断机制，但是无外围组件支持。

*还有一个不属于rtos范畴的，linux hhhhhhhhh，其实最开始做的第一版是uboot spl+压缩超精简linux，过程简直超级简单，体积12+647k，但是可以通过改openwrt代码来避免覆盖，然后楼主就被老爸胖揍一顿。。。。。。

综上，最后敲定rt-thread。

3.rtos-集成及遇到的问题
Rtos的集成主要分成几部分，中断体系适配和与uboot的集成。
这部分其实是硬伤，一般不看datasheet很难有所成，不过好在楼主老爸是mips架构老砖家了，边做边请教学起来简直so easy啊，简单来说，mips对中断的处理主要依靠status、cause等寄存器，具体这里就不列了，可以参考see mips run。
Uboot的集成这部分有一个明显的问题，就是rtos应该被集成在哪个阶段。众所周知，uboot启动按细分可分为四个阶段：flash、ram【重定向】、ram【解压镜像】、ram【解压镜像-重定向】，那么加载哪里好呢？
首先flash不可取，太慢；第一个ram阶段能加载的东西太少了，不可取；第二个ram阶段还没有重定向，也不可取，所以最终敲定最后一个阶段。
Rtos的启动代码放在这个阶段的哪个步骤呢？由于楼主只有一周时间，所以就偷了个懒，希望尽量使用uboot的代码，于是就放在了最后一步，main_loop之前。
还有一个问题是系统调用的方式，一般来说，可以直接使用函数调用，也可以像mips-linux那样使用syscall，syscall在linux下可以隔离用户应用于操作系统api，不过由于rtos所有程序都运行在内核态，因此使用syscall没啥卵用还占用了宝贵的上下文调度时间，所以使用第一种方式。

4.由于位置无关技术引发的特殊处理
Uboot由于需要避免与linux内核占内存，同时为了适应各种大小的内存，使用了位置无关技术，具体来说，就是利用gp指针指向全局变量表地址，每次取变量时，先从地址表查地址，然后再读取内容，这套技术一共使用了两个独特的寄存器gp、t9，gp寄存器的用处我们已经说完了，那么t9是干什么的呢？
由于位置无关技术允许有多个gp指针，所以，当子程序进入之后，首先要更新自己的gp指针，一般来说，可以通过pc相对寻址来找到gp指针，但是不幸的是，mips没有显示读取pc指针的方式，那么只有从过程调用下手，过程调用使用jalr t9的方式调用，此时子程序就从t9获得了自己的pc指针
这对于无os的开发没有什么大的影响，只要最开始维护好gp指针，一切后续都好说，但是对于os不是这样，因为中断发生时，谁也不能保证此时的gp指针是可用的，这就使得所有全局变量和函数不可用，事情一下子变得很尴尬起来
这个问题其实有两个解决方案，一个是我自己想的，一个是我爸教我的
（1）利用bal子函数调用和ra实现
在中断中，在使用gp之前，利用bal指令向后跳转两条指令，利用空出来的空间存放gp指针，跳转后，利用ra寄存器找到原位置，这需要对内存数据打补丁。
（2）对内存指令打patch实现
我爸提醒我，既然能对内存数据打补丁，当然也可以直接生成内存指令，具体操作是当系统初始化之后，根据gp在ebase指定的0x1000空间内写上几条指令
li k0 #gp
li k1 #program
jr k1
nop
如此，则完成了中断中gp指针环境的建立
由于使用了位置无关技术，因此还有一点需要注意，就是t9的维护。一个很容易被忽视的细节就是，当子线程启动时t9的维护，因此，操作系统建立堆栈时需要将t9指向thread_entry。

5.Demo
为了验证rt-uboot的集成性，做了个小demo，demo包括3个线程，一个是thread_main，用于执行uboot中的main_loop()函数，一个是thread_led，用于1Hz频率闪烁led，一个是后台worker，用于当idle哨兵顺带处理其他杂务（具体可以看代码）。

尾言
到这里一个多线程的rt-uboot就已经实现了，当然，目前的功能还只是引入了rtos，驱动还采用轮询的方式，那么下一步的操作也就是做一下基于中断的驱动【代码已完成串口和net】，顺带引入posix机制【代码已完成libc移植】、加入更多好玩的功能，由于楼主的学业任务比较繁重，第二篇第三篇什么时候能与大家见面还不一定，不过请大家放心，只要有时间，我就会搞这个的。

最最后，要感谢我都老爸老妈给与的悉心指导，还要感谢童年时代我的师叔----大连理工大学创新实验学院的李航老师给予的启蒙，就是在李航老师的指导下，我迈入了路由器的大坑。最后感谢大家的耐心观看！谢谢！